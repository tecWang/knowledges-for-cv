
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [排序](#排序)
  - [各排序算法的时间复杂度](#各排序算法的时间复杂度)
  - [各算法特点总结](#各算法特点总结)
    - [排序算法与时间复杂度关系](#排序算法与时间复杂度关系)
    - [排序算法与数组初始状态关系](#排序算法与数组初始状态关系)
  - [外排序与内排序](#外排序与内排序)
  - [比较排序](#比较排序)
    - [交换排序](#交换排序)
      - [冒泡排序](#冒泡排序)
      - [快速排序](#快速排序)
    - [插入排序](#插入排序)
      - [简单插入排序](#简单插入排序)
      - [折半插入排序](#折半插入排序)
      - [希尔排序](#希尔排序)
    - [选择排序](#选择排序)
      - [简单选择排序](#简单选择排序)
      - [堆排序](#堆排序)
    - [归并排序](#归并排序)
      - [二路归并排序](#二路归并排序)
  - [非比较排序](#非比较排序)
    - [计数排序](#计数排序)
    - [基数排序](#基数排序)
    - [拓扑排序](#拓扑排序)
- [查找](#查找)
  - [平均查找长度 ASL](#平均查找长度-asl)
  - [顺序查找](#顺序查找)
  - [二分查找](#二分查找)
    - [二分查找的平均查找长度](#二分查找的平均查找长度)
    - [计算有序数列的二分查找次数](#计算有序数列的二分查找次数)
  - [分块查找](#分块查找)
  - [Fibonacci查找](#fibonacci查找)
  - [判断图是否存在环(回路)](#判断图是否存在环回路)
- [References](#references)

<!-- /code_chunk_output -->

### 排序

排序算法主要可以分为两大类，比较类排序和非比较类排序。**比较类排序**通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为**非线性时间比较类排序**。**非比较类排序**不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 

![image](./images/sorting.png)

#### 各排序算法的时间复杂度

![image](./images/排序算法时间复杂度.png)

- 插入排序，冒泡排序，归并排序是稳定排序的算法
- 非比较排序都是稳定排序的算法

#### 各算法特点总结

##### 排序算法与时间复杂度关系
- 在序列基本有序的情况下，简单插入排序的比较次数最少，最快的时间复杂度可以到$O(n)$。
- 选择排序不论什么情况下都是$O(n^2)$
- 快速排序在序列越有序的情况下，时间复杂度越高，范围是$[O(nlogn), O(n^2)]$。快排的有序包括正序和逆序，因为快排主要是基于二分法的思想递归加速排序，而有序意味着二叉树会变成左斜树或右斜树，自然降低了快排的性能。

##### 排序算法与数组初始状态关系
- 算法复杂度与初始状态无关的有：选择排序、堆排序、归并排序、基数排序。
- 元素总比较次数与初始状态无关的有：选择排序、基数排序。
- 元素总移动次数与初始状态无关的有：归并排序、基数排序。
- 排序趟数与初始状态有关：快速排序(关键字选择)、优化后的冒泡排序(后序是否有序)

#### 外排序与内排序

排序方法按照排序过程中所涉及的存储器可分为内排序和外排序两种。

其中，待排序记录全部存放在计算机内存中进行排序的过程，称为内排序；而由于待排序记录的数量很大使得排序过程中也需要对外存设备进行访问的排序过程，称为外排序。

**外排序和内排序不只是考虑内外排序算法的性能，还要考虑IO数据交换效率的问题**，内存存取速度远远高于外存。

#### 比较排序

##### 交换排序

###### 冒泡排序

- 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
- 针对所有的元素重复以上的步骤，除了最后一个；
- 重复步骤1~3，直到排序完成。

需要注意的，冒泡排序并不是始终抓着一个元素从头比到尾，而是在比较过程中遇到了更大的元素就会更换被比较元素。即一个循环下来会交换不止一对元素。

![](./images/sort-bubble.gif)

```js
function bubbleSort(arr) {
    var len = arr.length;
    for(var i = 0; i < len - 1; i++) {
        for(var j = 0; j < len - 1 - i; j++) {
            if(arr[j] > arr[j+1]) {        // 相邻元素两两对比
                vartemp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
```

###### 快速排序

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：
- 从数列中挑出一个元素，称为 “基准”（pivot）；
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

![](./images/sort-quick-sort.gif)

```python
def quick_sort(left, right):

    if left > right:
        return

    temp = arr[left]    # 左侧第一个元素作为基准数
    i = left
    j = right

    while i != j:

        while arr[j] >= temp and i < j:
            j -= 1
        
        while arr[i] <= temp and i < j:
            i += 1

        if i < j:
            c = arr[i]
            arr[i] = arr[j]
            arr[j] = c

    arr[left] = arr[i]
    arr[i] = temp

    quick_sort(left, i-1)
    quick_sort(i+1, right)

    return
```

##### 插入排序

###### 简单插入排序

插入排序：是在一个已排好序的记录子集的基础上，每一步将下一个待排序的记录有序地入到已排好序的记录子集中，直到将所有待排记录全部插入为止。 

算法步骤:
- 从第一个元素开始，该元素可以认为已经被排序；
- 取出下一个元素，在已经排序的元素序列中从后向前扫描；
- 如果该元素（已排序）大于新元素，将该元素移到下一位置；
- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
- 将新元素插入到该位置后；
- 重复步骤2~5。

![image](./images/sort-insert.gif)

注:
- 插入排序的第一轮是从第二个元素开始的

###### 折半插入排序

折半插入排序，是对插入排序算法的一种改进，由于排序算法过程中，就是不断的依次将元素插入前面已排好序的序列中。**由于前半部分为已排好序的数列，这样我们不用按顺序依次寻找插入点，可以采用折半查找的方法来加快寻找插入点的速度。** 所以，很明显比较的次数减少了。

###### 希尔排序

1959年Shell发明，第一个突破$O(n^2)$的排序算法，是**简单插入排序的改进版**。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。

算法步骤:
先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：
- 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
- 按增量序列个数k，对序列进行k 趟排序；
- 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

![](./images/sort-shell.gif)

##### 选择排序

###### 简单选择排序

选择排序主要是每一趟从待排序列中选取一个关键码最小的记录，也即第一趟从n个记录中选取关键码最小的记录，第二趟从剩下的n-1个记录中选取关键码最小的记录，直到整个序列的记录选完。这样，由选取记录的顺序，便得到按关键码有序的序列。

![](./images/sort-selection.gif)

###### 堆排序

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

算法步骤:
- 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
- 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
- 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。

堆排序时间复杂度为O(nlogn)，初始建堆时间复杂度O(n)，一次重建堆时间复杂度O(logn)

```python
# TODO
```

##### 归并排序

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 

###### 二路归并排序

```python
arr = [6, 1, 2, 7, 9, 3, 4, 5, 10, 8]

def merge_sort(arr):

    # print("arr",arr, "len(arr)", len(arr))
    if len(arr) < 2:    # 即归并到只剩一个元素了
        return arr

    mid = (0 + len(arr) - 1) >> 1
    left = merge_sort(arr[0:mid+1])
    # print("left finished")
    right = merge_sort(arr[mid+1:])
    # print("right finished")

    return merge(left, right)


def merge(left, right):
    result = []
    while len(left) > 0 and len(right) > 0:
        if left[0] <= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0))
    
    if left:
        result += left

    if right:
        result += right

    print("result", result)
    return result

```

#### 非比较排序

##### 计数排序

##### 基数排序

基数排序是一种借助于多关键码排序的思想，是将单关键码按基数分成“多关键码”进行排序的方法。 

第一轮按照个位数字排序，第二轮按照十位数字排序。

![](./images/sort-radix-sort.gif)

##### 拓扑排序


二路归并排序的基本操作是将两个有序表合并为一个有序表。

### 查找

#### 平均查找长度 ASL

ASL是**查找算法的查找成功时的平均查找长度的缩写**，是为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值。$$ASL = \sum_{i=1}^{n}{P_iC_I}$$,其中$P_i$为查找表中第i个记录的概率, $C_i$为找到第i个记录数据需要比较的次数。

#### 顺序查找

弱顺序查找的平均查找长度$$ASL = \frac{1}{n}{\sum_{i=1}^{n}i} = \frac{1}{n}\frac{(1 + n)*n}{2} = \frac{n+1}{2}$$

#### 二分查找

##### 二分查找的平均查找长度

- 满二叉树时，若每个记录的查找概率相等时，$$ ASL = \frac{1}{n}{(1*2^0 + 2*2^1 + ... + h*2^{h-1})} $$ 令中间元素等于S，求解S的值，
$$\begin{aligned}
 S & = 1*2^0 + 2*2^1 + ... + h*2^{h-1} \\
 2S & = 1*2^1 + 2*2^2 + ... + h*2^h \\
 2S - S = S & = h*2^h - (2^0 + 2^1 + ... + 2^{h-1}) \\ 
\end{aligned}$$ 化简得
$$\begin{aligned}
 S & = h*2^h - \frac{1 - 2^h}{1 - 2} = h*2^h - (2^h - 1) \\
   & = (h - 1)2^h + 1 \\
   & = (\log_2{(n+1)}-1)*2^{\log_2{(n+1)}} + 1 \\
   & = (\log_2{(n+1)}-1)*(n+1) + 1 \\
   & = (n+1)\log_2{(n+1)} - n \\
\end{aligned}$$
带回原式可得，
$$ ASL = \frac{n+1}{n} * \log_2{(n+1)} - 1$$ 当n足够大时，$$ASL \approx \log_2{(n+1)} - 1$$
- 左斜树或右斜树时，二叉树退化为线性表，平均查找长度$ASL = (n+1)/2$

##### 计算有序数列的二分查找次数

在顺序表 { 12、15、17、20、24、30、38、43、45、51、52} 中，用二分法查找关键码20需做(  3  )次关键字比较。

解答：首先需要确定各个元素的索引[0, 10]，则 low=0, high=10
- 第一次查找：mid = (0 + 10) >> 1 = 5, data[5] = 30, high = mid - 1 = 4
- 第二次查找：mid = (0 + 4) >> 1 = 2, data[2] = 17, low = mid + 1 = 3
- 第三次查找：mid = (3 + 4) >> 1 = 3, data[3] = 20, 命中数据，共查找了三次。

需要注意的是左右两侧的 mid 更新时都需要移动一个位置。

#### 分块查找

分块查找的基本思想是首先在索引表中进行查找，以便确定给定的关键字可能存在的块号，然后再在相应的块内进行顺序查找。

#### Fibonacci查找

#### 判断图是否存在环(回路)

- 深度优先遍历。只要在其中记录下搜索的节点数n，当n大于图中节点数时退出，并可以得出有回路
- 拓扑排序。若有回路，则拓扑排序访问不到图中所有的节点，所以也可以得出回路


### References

- [十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/articles/7674659.html)
- [二叉搜索树的平均查找长度及时间复杂度](https://www.jianshu.com/p/10f5a659011a)
- [与数组初始状态无关的内排序算法](https://www.cnblogs.com/Xieyang-blog/p/8340578.html)